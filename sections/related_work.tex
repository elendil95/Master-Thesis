%Talk more about Thompson and morris, they introduce all the major techiques like hashing and salting at re-iterating the hash function.

\section{Related Work}
Both Password Cracking and deep learning are active areas of research developing at a rapid pace.

In this section, we aim to give an overview of the relevant knowledge in these areas as it relates to our thesis.

\subsection{Password Cracking}
Password cracking has been around for a long time, and while technology has evolved greatly and continues to do so, the basic concepts have remained relatively similar:
Back in 1979, Morris and Thompson were already aware of different ways to attack passwords and defend against such attacks \cite{Thompson1979}.

At the base of all password attacks is the concept of \emph{key space}, i.e the set of all possible passwords of a certain length that use a specific character set \cite{Thompson1979,hash_cat_mask_attack}. 
%Key sooace is theoretically infinite. add that.
%Maybe you could use that paper full of set thory math. Just check the scholarship beforefand.
In the case of the password \texttt{password}, the key space can be expressed $26^8$ (i.e The number of possible characters to the length of the string).

Key space is important because it is the basis from which password cracking techniques work off: if the password is sufficiently complex, an attacker will have to do an exhaustive search of the key space in order to find the password. 
It follows then, that one of principles of password strength is to make the search space big enough to be impractical to search through with current hardware.
This is the reason why users are commonly advised to use a variety of different characters classes in their passwords.\newline

To ground our discussion of search space in the context of cracking, we should address how passwords are stored in the first place: As Morris and Thompson explain in their paper, the simplest approach is to store the users' passwords in a file or database as they are entered: this is a bad idea as any software bug that causes an accidental disclosure will leave the users exposed, and also because any privileged user can simply look up the other users' passwords.

A better approach would be to encrypt the user's password, and store the cypher text: when a user logs in, the string they typed is compared with the cypher text and access is granted if it matches. This encryption is commonly achieved through a key derivation function or one-way cryptographic hash function, and Morris and Thompson use the DES algorithm in their paper. %Check that the terminology is correct.
Simply put, a cryptographic hash function is a mathematical function that, given a seed or key, encrypts a string in a predictable way; another feature of such function is that converting cypher text back into plain text should be exceedingly difficult, thus making reversing the process unfeasible.
This propriety however changes as the amount of available computing power increases, and any given hashing algorithm will eventually become insecure.

When a strong hashing algorithm is used, an attacker will theoretically have to do a key space search in order to crack the users' password: this process will take even more time, as every candidate string must be first encrypted with the same algorithm and then looked up in the database.

Encryption alone does not solve the problem however, because in reality an attacker would not have to resort to brute-forcing in a majority of cases.

Because the hashing algorithm needs to always output the same result for a given input string, the attacker can start comparing the hashes in the database and draw some conclusion: if some hashed appear many times, they probably hold the plain text of some very common passwords; If the attacker cracks those first and starts looking for similar patterns, he may crack a sizable number of the passwords contained in the database.

This leads us to our next attack strategy, which is to build a table with pre-computed hashes for all the most common passwords: this technique saves a lot of time since we do not need to encrypt every candidate password before comparing it with the database, and instead we merely look up the hashes from the table in the database. 

These tables are commonly referred to as \emph{Rainbow Tables}, and they are a simplified version of the rule-based techniques covered in section \ref{hash_and_jtr}.

Rainbow tables can be defeated by using \emph{password salting}: salting works by generating a random string that is then appended to the user's password before it is encrypted (mainly when the user first creates the account). The authors in \cite{Thompson1979} use a 12-bit random number as their salt, but modern sources suggest the use of longer and more complex salts \cite{NIST_2017}; by generating a unique salt per each user (or even better, per each individual password), Rainbow tables and correlation attacks will be rendered useless as its no longer possible to generate hashes of passwords that will work on the target; one might attempt to generate tables that contain salts, but this is impractical as it would mean brute-forcing the key space of the salt.
This can be done however in cases where the salt is very short, or alternatively when the system administrators have chosen one fixed salt string with which every password is processed.
The latter mistake its particularly grave, as it defeats the purpose of having salts in the first place.\neline
   
Its important to store the salt value in a proper manner however, because salted passwords may still vulnerable to rule-based attacks if the salt is leaked alongside the user's passwords.

Let us suppose that an attacker has access to both the hashed passwords of the users and the salts that each password uses: it is conceivable that one might extract all the salts from the database, put them in a dictionary, and use them in a rule-based dictionary attack such as the ones that will be described in section \ref{hash_and_jtr}: if the salt for each user is stored in the database, we do not need to brute-force the key space of the salt: every salt belongs to one of the users, hence we merely need to try them all sequentially on every password candidate. 

This would increase the difficulty of the attack by an order of magnitude and is unlikely, but it might be possible to carry out such an attack in a reasonable time given enough computing power. A remedy for such scenario is offered in \cite{NIST_2017} and will be discussed further down.\newline %FUCK ME WITH A RUSTY SPEAR, I HAVE NO IDEA IF THIS IS BS I JUST MADE UP!

For a more current example of how these security practices have evolved since 1979, we can look at the National Institute of Standards and Technologies' standard SP 800-63-3.
This standard is intended to provide security guideline for information systems within the US government, and was released in June 2017.

Document SP 800-63-3B \cite{NIST_2017}, provides guide-lines on how user secrets (passwords and/or PINs) should be stored.

They suggest that user password should be between 8 and 64 characters, but advise against enforcing password policies concerning the composition of passwords; Instead, they suggest that users passwords be checked against a list of leaked passwords and dictionary words before they are accepted, in order to avoid the use of weak passwords.

When it comes to encryption, they suggest the use of the PBKDF2 and Balloon algorithms; Other hashing algorithms listed as suitable for password encryption include HMAC and SHA-3.

Furthermore, they recommend that all passwords be salted with at least a 32bit quantity; to our understanding the standard calls for a unique salt for each user, as opposed to a unique salt for each password. The salts should be stored alongside the hashed password of the user.

In order to foil dictionary attacks in cases where the attacker has access to the users salts alongside the hashes, the system should perform an additional iteration of the encryption algorithm using a different 112bits salt that is secret, and should be stored on separate hardware form the main data.\newline
If we were to apply such process before encrypting the users password with the standard 32bit salt, this would effectively neutralize all dictionary attacks even when the attacker factors the salts into the process.

 
  
% An attacker's goal is to try to shrink the subset of the search space that needs to be examined in order to speed up the process, many times exploiting user habits or inherit characteristics of the password.\newline


%Password cracking can be accomplished in many ways, and the approach often depends on the situation: the attacker might be trying to gain access to a system by cracking the password of a high-privilege user like a System Administrator, or he might be cracking a leaked password database in order to later sell the personal data contained within.

%In the first scenario, we might try to learn as much as we can about the target and try to use social engineering techniques in order to obtain the password; Phishing and various kind of fraud are commonly used in such cases. %Needs a reference if you wanna keep it!

%In the second scenario, we are trying to extract as many password as possible from the leaked database and we might take advantage of user behavior in order to do so: Users tend to choose common passwords and to re-use the same password in multiple instances.%Also needs a reference 
%If we were to attack common passwords first, we can significantly reduce the combine search space.
%%Add more about passwords proper, for example about hashing algorithms and salting?

\subsection{Rule-Based password crackers} \label{hash_and_jtr}
%Define rules firrst in the introduction

Two common tools for password cracking are John The Ripper and \break \mbox{HashCat}\cite{john,hash_cat}: these tools take advantage of common patterns in user behaviour in order to optimize the cracking process: Both tools have a variety of techniques an attacker can employ, and we will briefly exemplify their capabilities using HashCat as an example \cite{hash_cat_wiki}: \newline

In both tools there are three categories of attacks that can be carried out: brute-force attacks, dictionaries attacks and rule based attacks: these can be combined and tweaked in various ways depending on the desired result, and there is a degree of overlap between each.\newline 
%Devidide it in 3 sub-sections and define them better

HashCat's \enquote{modes} reflect these categories, and the simplest of these is \emph{Mask attack} mode: this is modified version of key space search, meant to attack simpler passwords while shrinking the key space search: 
instead of searching the total space for a password of length $x$, we define a simple regular pattern expressing the what character classes are there and at which position, saving us a substantial amount of processing time.
For example is we have a password like \texttt{Benjamin86} or \texttt{Iloveyou02}, we can define our pattern to be a ten-character string with eight lowercase or uppercase letters and two numbers at the end; This is referred to as a \emph{Mask} in HashCat's documentation:

In a classic brute-force attack we would deal with a search space of $62^{10}$ (or roughly $8 \times 10^{17}$ combinations), but thanks to the above-mentioned mask we can reduce our search space to around $4 \times 10^{13}$ possibilities if we assume that the first character in the string is the only one that can be uppercase.
Furthermore we can use the \texttt{--increment } option in HashCat to apply this pattern to all strings up to ten characters, allowing us to match shorter passwords that follow the same pattern.

This method is rather simplistic and not very flexible, but exemplifies some of the ways in which attackers can optimize key space attacks.\newline

The main mode of operation oh HashCat \emph{straight} mode, that performs a dictionary attack: In this mode, the program is fed a wordlist/dictionary, and tries each entry the wordlist as a password candidate. Because of its simplicity, such a dictionary attack works best with a wordlist composed of leaked passwords; the aim is to target very common passwords and users that re-use passwords, but the effectiveness of such an attack can increase significantly depending on what wordlist is used.

Dictionary attacks can be further enhanced by combining them in various ways: one approach would be to use two wordlists and append/prepend each entry in the second one to each entry in the first; 
the second wordlist might be a natural language dictionary or a wordlist of plain-text leaked passwords. This is called \emph{Combinator attack} mode in HashCat. 
We might also want to use the output of a brute-force attempt as out second wordlist: If we use the patterns described in the Mask Attack mode to generate strings we combine with a wordlist, we will obtained a more targeted and effective version of the Mask Attack method. 
For example is we know that a good deal of the passwords we want to extract are strings with numbers appended to the end, we might run a mask that generates combinations of 0 to 4 digits and then combine the output of that with our wordlist. This is called \emph{Hybrid attack } mode in HashCat.\newline

Finally we come to rule-based attacks: In short they are an extension of all the methods described above, and all the aforementioned techniques can also be performed using rules; however, rules are more flexible and allow for more thorough definition of the patterns that may appear in a password, going beyond the capabilities of a regular language.
Patterns can be created independently of the size and characteristics of the passwords, and they are not limited to a fixed patterns; there are also flow control statements and options to apply rules only in certain conditions.
There are also options to save password candidates to memory enabling more advanced processing: saved strings can be appended to each pasword candidate matching certain criteria, reversed and so on...

Rules are applied to each entry in a wordlist in a similar way to a combinator attack, and multiple rules can also be be applied sequentially to the same entry in the wordlist.
Rules provide a more efficient way to tackle password cracking since their greater flexibility means that an attacker need not know as much about their target. 

%ADD SOME RULES EXAMPLES

